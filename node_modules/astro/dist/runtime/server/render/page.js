import { AstroError } from "../../../core/errors/index.js";
import { isHTMLString } from "../escape.js";
import { createResponse } from "../response.js";
import { isAstroComponentFactory, isAstroComponentInstance } from "./astro/index.js";
import { renderToReadableStream, renderToString } from "./astro/render.js";
import { HTMLParts, encoder } from "./common.js";
import { renderComponent } from "./component.js";
import { maybeRenderHead } from "./head.js";
const needsHeadRenderingSymbol = Symbol.for("astro.needsHeadRendering");
function nonAstroPageNeedsHeadInjection(pageComponent) {
  return needsHeadRenderingSymbol in pageComponent && !!pageComponent[needsHeadRenderingSymbol];
}
async function iterableToHTMLBytes(result, iterable, onDocTypeInjection) {
  const parts = new HTMLParts();
  let i = 0;
  for await (const chunk of iterable) {
    if (isHTMLString(chunk)) {
      if (i === 0) {
        i++;
        if (!/<!doctype html/i.test(String(chunk))) {
          parts.append(`${result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n"}`, result);
          if (onDocTypeInjection) {
            await onDocTypeInjection(parts);
          }
        }
      }
    }
    parts.append(chunk, result);
  }
  return parts.toArrayBuffer();
}
async function renderPage(result, componentFactory, props, children, streaming, route) {
  var _a, _b;
  if (!isAstroComponentFactory(componentFactory)) {
    result._metadata.headInTree = ((_a = result.componentMetadata.get(componentFactory.moduleId)) == null ? void 0 : _a.containsHead) ?? false;
    const pageProps = { ...props ?? {}, "server:root": true };
    let output;
    let head = "";
    try {
      if (nonAstroPageNeedsHeadInjection(componentFactory)) {
        const parts = new HTMLParts();
        for await (const chunk of maybeRenderHead()) {
          parts.append(chunk, result);
        }
        head = parts.toString();
      }
      const renderResult = await renderComponent(
        result,
        componentFactory.name,
        componentFactory,
        pageProps,
        null
      );
      if (isAstroComponentInstance(renderResult)) {
        output = renderResult.render();
      } else {
        output = renderResult;
      }
    } catch (e) {
      if (AstroError.is(e) && !e.loc) {
        e.setLocation({
          file: route == null ? void 0 : route.component
        });
      }
      throw e;
    }
    const bytes = await iterableToHTMLBytes(result, output, async (parts) => {
      parts.append(head, result);
    });
    return new Response(bytes, {
      headers: new Headers([
        ["Content-Type", "text/html; charset=utf-8"],
        ["Content-Length", bytes.byteLength.toString()]
      ])
    });
  }
  result._metadata.headInTree = ((_b = result.componentMetadata.get(componentFactory.moduleId)) == null ? void 0 : _b.containsHead) ?? false;
  let body;
  if (streaming) {
    body = await renderToReadableStream(result, componentFactory, props, children, true, route);
  } else {
    body = await renderToString(result, componentFactory, props, children, true, route);
  }
  if (body instanceof Response)
    return body;
  const init = result.response;
  const headers = new Headers(init.headers);
  if (!streaming && typeof body === "string") {
    body = encoder.encode(body);
    headers.set("Content-Length", body.byteLength.toString());
  }
  const response = createResponse(body, { ...init, headers });
  return response;
}
export {
  renderPage
};
